module std::os::linux;

// x86_64 specific declaration
pub type SYS = enum usize {
    read = 0,
    write = 1,
    open = 2,
    close = 3,
    stat = 4,
    fstat = 5,
    lstat = 6,
    poll = 7,
    lseek = 8,
    mmap = 9,
    mprotect = 10,
    munmap = 11,
    brk = 12,
    rt_sigaction = 13,
    rt_sigprocmask = 14,
    rt_sigreturn = 15,
    ioctl = 16,
    pread64 = 17,
    pwrite64 = 18,
    readv = 19,
    writev = 20,
    access = 21,
    pipe = 22,
    select = 23,
    sched_yield = 24,
    mremap = 25,
    msync = 26,
    mincore = 27,
    madvise = 28,
    shmget = 29,
    shmat = 30,
    shmctl = 31,
    dup = 32,
    dup2 = 33,
    pause = 34,
    nanosleep = 35,
    getitimer = 36,
    alarm = 37,
    setitimer = 38,
    getpid = 39,
    sendfile = 40,
    socket = 41,
    connect = 42,
    accept = 43,
    sendto = 44,
    recvfrom = 45,
    sendmsg = 46,
    recvmsg = 47,
    shutdown = 48,
    bind = 49,
    listen = 50,
    getsockname = 51,
    getpeername = 52,
    socketpair = 53,
    setsockopt = 54,
    getsockopt = 55,
    clone = 56,
    fork = 57,
    vfork = 58,
    execve = 59,
    exit = 60,
    wait4 = 61,
    kill = 62,
    uname = 63,
    semget = 64,
    semop = 65,
    semctl = 66,
    shmdt = 67,
    msgget = 68,
    msgsnd = 69,
    msgrcv = 70,
    msgctl = 71,
    fcntl = 72,
    flock = 73,
    fsync = 74,
    fdatasync = 75,
    truncate = 76,
    ftruncate = 77,
    getdents = 78,
    getcwd = 79,
    chdir = 80,
    fchdir = 81,
    rename = 82,
    mkdir = 83,
    rmdir = 84,
    creat = 85,
    link = 86,
    unlink = 87,
    symlink = 88,
    readlink = 89,
    chmod = 90,
    fchmod = 91,
    chown = 92,
    fchown = 93,
    lchown = 94,
    umask = 95,
    gettimeofday = 96,
    getrlimit = 97,
    getrusage = 98,
    sysinfo = 99,
    times = 100,
    ptrace = 101,
    getuid = 102,
    syslog = 103,
    getgid = 104,
    setuid = 105,
    setgid = 106,
    geteuid = 107,
    getegid = 108,
    setpgid = 109,
    getppid = 110,
    getpgrp = 111,
    setsid = 112,
    setreuid = 113,
    setregid = 114,
    getgroups = 115,
    setgroups = 116,
    setresuid = 117,
    getresuid = 118,
    setresgid = 119,
    getresgid = 120,
    getpgid = 121,
    setfsuid = 122,
    setfsgid = 123,
    getsid = 124,
    capget = 125,
    capset = 126,
    rt_sigpending = 127,
    rt_sigtimedwait = 128,
    rt_sigqueueinfo = 129,
    rt_sigsuspend = 130,
    sigaltstack = 131,
    utime = 132,
    mknod = 133,
    uselib = 134,
    personality = 135,
    ustat = 136,
    statfs = 137,
    fstatfs = 138,
    sysfs = 139,
    getpriority = 140,
    setpriority = 141,
    sched_setparam = 142,
    sched_getparam = 143,
    sched_setscheduler = 144,
    sched_getscheduler = 145,
    sched_get_priority_max = 146,
    sched_get_priority_min = 147,
    sched_rr_get_interval = 148,
    mlock = 149,
    munlock = 150,
    mlockall = 151,
    munlockall = 152,
    vhangup = 153,
    modify_ldt = 154,
    pivot_root = 155,
    sysctl = 156,
    prctl = 157,
    arch_prctl = 158,
    adjtimex = 159,
    setrlimit = 160,
    chroot = 161,
    sync = 162,
    acct = 163,
    settimeofday = 164,
    mount = 165,
    umount2 = 166,
    swapon = 167,
    swapoff = 168,
    reboot = 169,
    sethostname = 170,
    setdomainname = 171,
    iopl = 172,
    ioperm = 173,
    create_module = 174,
    init_module = 175,
    delete_module = 176,
    get_kernel_syms = 177,
    query_module = 178,
    quotactl = 179,
    nfsservctl = 180,
    getpmsg = 181,
    putpmsg = 182,
    afs_syscall = 183,
    tuxcall = 184,
    security = 185,
    gettid = 186,
    readahead = 187,
    setxattr = 188,
    lsetxattr = 189,
    fsetxattr = 190,
    getxattr = 191,
    lgetxattr = 192,
    fgetxattr = 193,
    listxattr = 194,
    llistxattr = 195,
    flistxattr = 196,
    removexattr = 197,
    lremovexattr = 198,
    fremovexattr = 199,
    tkill = 200,
    time = 201,
    futex = 202,
    sched_setaffinity = 203,
    sched_getaffinity = 204,
    set_thread_area = 205,
    io_setup = 206,
    io_destroy = 207,
    io_getevents = 208,
    io_submit = 209,
    io_cancel = 210,
    get_thread_area = 211,
    lookup_dcookie = 212,
    epoll_create = 213,
    epoll_ctl_old = 214,
    epoll_wait_old = 215,
    remap_file_pages = 216,
    getdents64 = 217,
    set_tid_address = 218,
    restart_syscall = 219,
    semtimedop = 220,
    fadvise64 = 221,
    timer_create = 222,
    timer_settime = 223,
    timer_gettime = 224,
    timer_getoverrun = 225,
    timer_delete = 226,
    clock_settime = 227,
    clock_gettime = 228,
    clock_getres = 229,
    clock_nanosleep = 230,
    exit_group = 231,
    epoll_wait = 232,
    epoll_ctl = 233,
    tgkill = 234,
    utimes = 235,
    vserver = 236,
    mbind = 237,
    set_mempolicy = 238,
    get_mempolicy = 239,
    mq_open = 240,
    mq_unlink = 241,
    mq_timedsend = 242,
    mq_timedreceive = 243,
    mq_notify = 244,
    mq_getsetattr = 245,
    kexec_load = 246,
    waitid = 247,
    add_key = 248,
    request_key = 249,
    keyctl = 250,
    ioprio_set = 251,
    ioprio_get = 252,
    inotify_init = 253,
    inotify_add_watch = 254,
    inotify_rm_watch = 255,
    migrate_pages = 256,
    openat = 257,
    mkdirat = 258,
    mknodat = 259,
    fchownat = 260,
    futimesat = 261,
    fstatat64 = 262,
    unlinkat = 263,
    renameat = 264,
    linkat = 265,
    symlinkat = 266,
    readlinkat = 267,
    fchmodat = 268,
    faccessat = 269,
    pselect6 = 270,
    ppoll = 271,
    unshare = 272,
    set_robust_list = 273,
    get_robust_list = 274,
    splice = 275,
    tee = 276,
    sync_file_range = 277,
    vmsplice = 278,
    move_pages = 279,
    utimensat = 280,
    epoll_pwait = 281,
    signalfd = 282,
    timerfd_create = 283,
    eventfd = 284,
    fallocate = 285,
    timerfd_settime = 286,
    timerfd_gettime = 287,
    accept4 = 288,
    signalfd4 = 289,
    eventfd2 = 290,
    epoll_create1 = 291,
    dup3 = 292,
    pipe2 = 293,
    inotify_init1 = 294,
    preadv = 295,
    pwritev = 296,
    rt_tgsigqueueinfo = 297,
    perf_event_open = 298,
    recvmmsg = 299,
    fanotify_init = 300,
    fanotify_mark = 301,
    prlimit64 = 302,
    name_to_handle_at = 303,
    open_by_handle_at = 304,
    clock_adjtime = 305,
    syncfs = 306,
    sendmmsg = 307,
    setns = 308,
    getcpu = 309,
    process_vm_readv = 310,
    process_vm_writev = 311,
    kcmp = 312,
    finit_module = 313,
    sched_setattr = 314,
    sched_getattr = 315,
    renameat2 = 316,
    seccomp = 317,
    getrandom = 318,
    memfd_create = 319,
    kexec_file_load = 320,
    bpf = 321,
    execveat = 322,
    userfaultfd = 323,
    membarrier = 324,
    mlock2 = 325,
    copy_file_range = 326,
    preadv2 = 327,
    pwritev2 = 328,
    pkey_mprotect = 329,
    pkey_alloc = 330,
    pkey_free = 331,
    statx = 332,
    io_pgetevents = 333,
    rseq = 334,
    pidfd_send_signal = 424,
    io_uring_setup = 425,
    io_uring_enter = 426,
    io_uring_register = 427,
    open_tree = 428,
    move_mount = 429,
    fsopen = 430,
    fsconfig = 431,
    fsmount = 432,
    fspick = 433,
    pidfd_open = 434,
    clone3 = 435,
    close_range = 436,
    openat2 = 437,
    pidfd_getfd = 438,
    faccessat2 = 439,
    process_madvise = 440,
    epoll_pwait2 = 441,
    mount_setattr = 442,
    quotactl_fd = 443,
    landlock_create_ruleset = 444,
    landlock_add_rule = 445,
    landlock_restrict_self = 446,
    memfd_secret = 447,
    process_mrelease = 448,
    futex_waitv = 449,
    set_mempolicy_home_node = 450,
    cachestat = 451,
    fchmodat2 = 452,
    map_shadow_stack = 453,
    futex_wake = 454,
    futex_wait = 455,
    futex_requeue = 456,
    statmount = 457,
    listmount = 458,
    lsm_get_self_attr = 459,
    lsm_set_self_attr = 460,
    lsm_list_modules = 461,
    mseal = 462,
};

// x86_64 specific declaration
pub fn syscall1(code SYS, arg1 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
        : "rcx", "r11", "memory"
    };
}

// x86_64 specific declaration
pub fn syscall2(code SYS, arg1 usize, arg2 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
          "{rsi}" (arg2),
        : "rcx", "r11", "memory"
    };
}

// x86_64 specific declaration
pub fn syscall3(code SYS, arg1 usize, arg2 usize, arg3 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
          "{rsi}" (arg2),
          "{rdx}" (arg3),
        : "rcx", "r11", "memory"
    };
}

// x86_64 specific declaration
pub fn syscall4(code SYS, arg1 usize, arg2 usize, arg3 usize, arg4 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
          "{rsi}" (arg2),
          "{rdx}" (arg3),
          "{r10}" (arg4),
        : "rcx", "r11", "memory"
    };
}

// x86_64 specific declaration
pub fn syscall5(code SYS, arg1 usize, arg2 usize, arg3 usize, arg4 usize, arg5 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
          "{rsi}" (arg2),
          "{rdx}" (arg3),
          "{r10}" (arg4),
          "{r8}" (arg5),
        : "rcx", "r11", "memory"
    };
}

// x86_64 specific declaration
pub fn syscall6(code SYS, arg1 usize, arg2 usize, arg3 usize, arg4 usize, arg5 usize, arg6 usize) usize {
    return asm {
        "syscall"
        : "={rax}" (usize)
        : "{rax}" (code),
          "{rdi}" (arg1),
          "{rsi}" (arg2),
          "{rdx}" (arg3),
          "{r10}" (arg4),
          "{r8}" (arg5),
          "{r9}" (arg6),
        : "rcx", "r11", "memory"
    };
}

pub fn read(fd s32, bufferptr usize, count usize) usize {
    return syscall3(SYS::read, (&fd as *u32).*, bufferptr, count);
}

pub const STDIN = 0;
pub const STDOUT = 1;
pub const STDERR = 2;

pub fn write(fd s32, bufferptr usize, count usize) usize {
    return syscall3(SYS::write, (&fd as *u32).*, bufferptr, count);
}

pub fn open(path [*]const u8, flags u32) s32 {
    return (&(syscall2(SYS::open, path as usize, flags) as u32) as *s32).*;
}

pub fn close(fd s32) s32 {
    return (&(syscall1(SYS::close, (&fd as *u32).* as usize) as u32) as *s32).*;
}

pub type timespec = struct {
    sec ssize,
    nsec ssize,
};

pub type uid_t = u32;
pub type gid_t = u32;
pub type off_t = s64;
pub type ino_t = u64;
pub type dev_t = u64;

// x86_64 specific declaration
pub type Stat = struct {
    dev dev_t,
    ino ino_t,
    nlink usize,
    mode u32,
    uid uid_t,
    gid gid_t,
    __pad0 u32,
    rdev dev_t,
    size off_t,
    blksize ssize,
    blocks s64,
    atim timespec,
    mtim timespec,
    ctim timespec,
    __unused [3]ssize,
};

pub type statx_timestamp = struct {
    sec s64,
    nsec u32,
    __pad1 u32,
};

pub type Statx = struct {
    mask u32,
    blksize u32,
    attributes u64,
    nlink u32,
    uid uid_t,
    gid gid_t,
    mode u16,
    __pad1 u16,
    ino u64,
    size u64,
    blocks u64,
    attributes_mask u64,
    atime statx_timestamp,
    btime statx_timestamp,
    ctime statx_timestamp,
    mtime statx_timestamp,
    rdev_major u32,
    rdev_minor u32,
    dev_major u32,
    dev_minor u32,
    __pad2 [14]u64,
};

pub fn stat(path [*]const u8, statbuf *Stat) usize {
    return syscall2(SYS::stat, path as usize, statbuf as usize);
}

pub fn lstat(path [*]const u8, statbuf *Stat) usize {
    return syscall2(SYS::lstat, path as usize, statbuf as usize);
}

pub fn fstat(fd s32, statbuf *Stat) usize {
    return syscall2(SYS::fstat, (&fd as *u32).* as usize, statbuf as usize);
}

pub fn fstatat(dirfd s32, path [*]const u8, statbuf *Stat, flags u32) usize {
    return syscall5(SYS::fstatat64, (&dirfd as *u32).*, path as usize, statbuf as usize, flags);
}

pub fn statx(dirfd s32, path [*]const u8, flags u32, mask u32, statxbuf *Statx) usize {
    return syscall6(SYS::statx, (&dirfd as *u32).*, path as usize, flags, mask, statxbuf as usize);
}

pub fn sendfile(outfd s32, infd s32, offset *s64, count usize) usize {
    return syscall6(SYS::sendfile, (&outfd as *u32).*, (&infd as *u32).*, offset as usize, count, 0);
}

pub fn sendto(fd s32, buf [*]const u8, len usize, flags u32, addr *const sockaddr, addrlen socklen_t) usize {
    return syscall6(SYS::sendto, (&fd as *u32).*, buf as usize, len, flags, addr as usize, addrlen);
}

pub fn access(path [*]const u8, mode u32) usize {
    return syscall3(SYS::access, path as usize, mode, 0);
}

pub const AF_INET = 2;
pub const SOCK_STREAM = 1;

pub fn socket(domain u32, type_ u32, protocol u32) s32 {
    return (&(syscall3(SYS::socket, domain, type_, protocol) as u32) as *s32).*;
}

pub const SOL_SOCKET = 1;
pub const SO_REUSEADDR = 2;
pub const SO_REUSEPORT = 15;

pub fn setsockopt(fd s32, level u32, optname u32, optvalptr usize, optlen usize) {
    syscall5(SYS::setsockopt, (&fd as *u32).*, level, optname, optvalptr, optlen);
}

pub type sa_family_t = u16;
pub type in_port_t = u16;
pub type socklen_t = u32;

pub type sockaddr = struct {
   family sa_family_t,
   data [14]u8,
};

pub type sockaddr::in = struct {
    family sa_family_t,
    port in_port_t,
    addr u32,
    zero [8]u8,
};

pub fn accept(fd s32, addr *sockaddr, addrlenptr *socklen_t) s32 {
    return (&(syscall4(SYS::accept, (&fd as *u32).*, addr as usize, addrlenptr as usize, 0) as u32) as *s32).*;
}

pub fn bind(fd s32, addr *const sockaddr, addrlen socklen_t) usize {
    return syscall3(SYS::bind, (&fd as *u32).*, addr as usize, addrlen as usize);
}

pub fn listen(fd s32, backlog u32) usize {
    return syscall2(SYS::listen, (&fd as *u32).*, backlog);
}

pub fn exit(status u8) {
    syscall1(SYS::exit, status);
}

pub fn exit_group(status u8) {
    syscall1(SYS::exit_group, status);
}

pub fn mmap(addr usize, length usize, prot u32, flags u32, fd s32, offset s64) usize {
    return syscall6(SYS::mmap, addr, length, prot, flags, (&fd as *u32).*, (&offset as *u64).*);
}

pub fn mprotect(addr usize, length usize, prot u32) s32 {
    return (&(syscall3(SYS::mprotect, addr, length, prot) as u32) as *s32).*;
}

pub fn munmap(addr usize, length usize) s32 {
    return (&(syscall2(SYS::munmap, addr, length) as u32) as *s32).*;
}

pub fn mremap(old_addr usize, old_len usize, new_len usize, flags u32, new_addr usize) usize {
    return syscall5(SYS::mremap, old_addr, old_len, new_len, flags, new_addr);
}
